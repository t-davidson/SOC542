---
title: '542: Week 2 - Regression Review'
author: "Fred Traylor, Lab TA"
date: "1/31/2022"
output:
  pdf_document: default
  html_document: default
editor_options:
  markdown:
    wrap: 72
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
options(scipen = 999)

library(tidyverse)
library(gapminder)
library(stargazer)
```


# Loading and Visualizing Our Variables

We're going to use the `gapminder` package to load up our data. The Gapminder project has data on a wide variety of indicators, for most countries of the world, and for many decades. This provides a great opportunity for us to analyze development.

To make it easier to conceptualize, we're going to start with just a sample of data from the United States of America. 

```{r data-load}
usadata <- gapminder::gapminder_unfiltered %>% 
  filter(country == "United States") %>% 
  select(-country, -continent)
head(usadata) # shows the top of the table
```

Looking at the data information with `?gapminder`, we can see that there are six variables.

1.  country = Country Name (removed from our dataset on line 35)
2.  continent = Continent Name (removed from our dataset on line 35)
3.  year = Year, ranges from 1952 to 2007
4.  lifeExp = Life expectancy at birth, in years
5.  pop = population
6.  gdpPercap = GDP per capita, USD, inflation-adjusted

Let's take a look at these data. And especially, let's look at the relationship between year and life expectancy using ggplot.

```{r data-viz}
ggplot(usadata, aes(x = year,y = lifeExp)) +
  geom_line()
```

# OLS Regression
OLS regression in R uses the `lm()` function, short for "Linear Model." Below, let's regress life expectancy on year to see how life expectancy has increased over time. 

We'll also use two ways to display the results, `summary()` and `stargazer::stargazer()`. 

```{r regression}
mod1 <- lm(lifeExp ~ year,       # Regress life expectancy on year
           data = usadata)       # Using data from usadata 

summary(mod1)
```

From these results, we can see that life expectancy in the USA increased at a rate of 0.182 additional years of expected life each year, starting at -287.415 years in the year zero. (Of course, we didn't start at year 0; our data start in year 1952.)

Looking back at our summary table, our R-squared is very high (.981), suggesting that around 98% of the variations in life expectancy can be explained by the passage of time.

We can use the `stargazer` package to create cleaner looking regression tables for publications. Additional arguments can be supplied to customize the appearance of the table.

```{r regression-output}
stargazer(mod1, 
          type = "text")
```

## Predictions
After running a regression, we often want to use it to predict a specific value. Recalling that our regression equation is $y = \beta_0 + \beta_1x$, we can substitute our intercept for $\beta_0$ and our year coefficient for $\beta_1$, giving us the new equation, $lifeExp = -287.415 + 0.182*year$. Using this equation, we can plug in any point we want for the value of year and get a predicted value for life expectancy. 

*NOTE: These equations are bookended with dollar signs so that, in the knitted version of this document, they'll be converted to a readable version of an equation. You can hover your mouse over any part of the equation, and it'll show you what it would look like in the document.*


In this case, we can directly access the coefficients in the `mod1` object. We can then use indexing to access the relevant elements. Note that some incorrect text naming is left over the first time. We can escape this by using `[[]]` to select the contents of each value.
```{r predict-byhand}
new_year <- 1970

mod1$coefficients

mod1$coefficients[1] + mod1$coefficients[2]*new_year

mod1$coefficients[1][[1]] + mod1$coefficients[2][[1]]*new_year # better
```

R also has the `predict()` function, which does the same thing. Just note, though, that the new year must be in the form of a data frame. This means we can easily calculate multiple predicted values at once.
```{r predict-function}
new_year <- data.frame(year = 1970)

pred <- predict(mod1, new_year)
print(pred)
```

## Residuals 
How far is this predicted point from the actual value for 1970, though? Looking at our dataset, we can see that it was actually 70.92, a little bit away from the predicted value above. We can calculate exactly how far it is by subtracting the predicted value from the actual value.

```{r resid-byhand}
realval <- usadata %>% 
  select(year, lifeExp) %>% 
  filter(year == 1970)
head(realval)

pred - realval$lifeExp
```

Like with `predict()`, R has another built-in function to shorten this process for us, called `resid()` or `residuals()`. Let's use that function, and our `predict()` function from earlier, to add the predicted and residual values onto our original dataframe.
```{r add-predict-resid}
usadata$predicted <- predict(mod1)
usadata$resid <- residuals(mod1)
```


### Graphing Residuals 

A first look at the residuals warrants seeing if there are any values that are poorly predicted. We can graph a histogram of residuals to see this.
```{r resid-hist}
ggplot(data = usadata, aes(x = resid)) + geom_histogram(bins=20)
```
This shows us that, while most residuals are very close to zero, there are still a few that are further away. 

Since residuals can also be negative, let's also graph a histogram of the absolute values of the residuals.
```{r resid-hist-abs}
ggplot(data = usadata, aes(x = abs(resid))) + geom_histogram(bins=20)
```

A handy graph in inspecting our regression model is the residual plot. Our x-axis here is the predicted values of life expectancy, and our y-axis is the residuals. 

```{r resid-plot}
ggplot(usadata,
       aes(x = predicted,
           y = resid)) +
  geom_point() +
  geom_hline(yintercept = 0, linetype = "dotted") +
  ggtitle("Residual Plot") +
  theme_classic()

```

Lastly, let's plot this graph side-by-side with our original graph. We're going to use the `plot_grid()` function, contained in the `cowplot` package. Create each graph separately, save each as its own object, then run `cowplot::plot_grid(graph1, graph2)`.
```{r compare-graphs}
origplot <- ggplot(usadata,
                   aes(x = year,
                       y = lifeExp)) +
  geom_point() +
  geom_smooth(method = "lm") +
  ggtitle("Life Expectancy vs. Year") +
  theme_classic()

residplot <- ggplot(usadata,
                    aes(x = predicted,
                        y = resid)) +
  geom_point() +
  geom_hline(yintercept = 0, linetype = "dotted") +
  ggtitle("Residual Plot") +
  theme_classic()

if(!require(cowplot))          # If cowplot package isn't intalled...
  install.packages("cowplot")  # Install it

cowplot::plot_grid(origplot, residplot)
```





