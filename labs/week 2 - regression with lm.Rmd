---
title: '542: Week 2 - Regression Review'
author: "Fred Traylor, Lab TA"
date: "1/31/2022"
output: html_document
editor_options: 
  markdown: 
    wrap: 72
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
options(scipen = 999)

# The pacman package allows us to specify packages we'll need throughout the analysis
   # It installs them if they aren't already installed, and then loads them up for us 
if (!require("pacman"))         # If pacman isn't installed...
  install.packages("pacman")    # This will install it for you

pacman::p_load(tidyverse, gapminder, stargazer)  # Put needed packages here 
```


## Loading and Visualizing Our Variables

We're going to use the `gapminder` package to load up our data. The Gapminder project has data on a wide variety of indicators, for most countries of the world, and for many decades. This provides a great opportunity for us to analyze development.

To make it easier to conceptualize, we're going to start with just a sample of data from the United States of America. 

```{r data-load}

usadata <- gapminder::gapminder_unfiltered %>% 
  filter(country == "United States") %>% 
  select(-country, -continent)
usadata
```

Looking at the data information with `?gapminder`, we can see that there are six variables.

1.  country = Country Name (removed from our dataset on line 35)
2.  continent = Continent Name (removed from our dataset on line 35)
3.  year = Year, ranges from 1952 to 2007
4.  lifeExp = Life expectancy at birth, in years
5.  pop = population
6.  gdpPercap = GDP per capita, USD, inflation-adjusted

Let's take a look at these data. And especially, let's look at the relationship between year and life expectancy.

```{r data-viz}
plot(usadata)
ggplot(usadata,
       aes(x = year,
           y = lifeExp)) +
  geom_point()
```

## OLS Regression
OLS regression in R uses the `lm()` function, short for "Linear Model." Below, let's regress life expectancy on year to see how life expectancy has increased over time. 

We'll also use two ways to display the results, `summary()` and `stargazer::stargazer()`. 

```{r regression}
mod1 <- lm(lifeExp ~ year,       # Regress life expectancy on year
           data = usadata)       # Using data from usadata 


# Two ways to display model results 
summary(mod1)
stargazer(mod1, 
          type = "text")


```


From these results, we can see that life expectancy in the USA increased at a rate of 0.182 additional years of expected life each year, starting at -287.415 years in the year zero. (Of course, we didn't start at year 0; our data start in year 1952.)

Looking back at our summary table, our R-squared is very high (.981), suggesting that around 98% of the variations in life expectancy can be explained by the passage of time.


## Predictions and Residuals

### Predictions
After running a regression, we often want to use it to predict a specific value. Recalling that our regression equation is $y = a + bx$, we can substitute our intercept for $a$ and our year coefficient for $b$, giving us the new equation, $lifeExp = -287.415 + 0.182*year$. Using this equation, we can plug in any point we want for the value of year and get a predicted value for life expectancy. 

(NOTE: These equations are bookended with dollar signs so that, in the knitted version of this document, they'll be converted to a readable version of an equation. You can hover your mouse over any part of the equation, and it'll show you what it would look like in the document.)

```{r predict-byhand}
new_year = 1970

-287.414516 + 0.182311*new_year
```

R also has the `predict()` function, which does the same thing. Just note, though, that the new year must be in the form of a data frame.  
```{r predict-function}
new_year = data.frame(year = 1970)

predict(mod1, new_year)
```

### Residuals 
How far is this predicted point from the actual value for 1970, though? Looking at our dataset, we can see that it was actually 70.92, a little bit away from the predicted value above. We can calculate exactly how far it is by subtracting the predicted value from the actual value.

```{r resid-byhand}

realval <- usadata %>% 
  select(year, lifeExp) %>% 
  filter(year == 1970)
realval

new_year = data.frame(year = 1970)
predict(mod1, new_year) - realval$lifeExp

```

Like with `predict()`, R has another built-in function to shorten this process for us, called `resid()` or `residuals()`. Let's use that function, and our `predict()` function from earlier, to add the predicted and residual values onto our original dataframe.
```{r add-predict-resid}
usadata$predicted <- predict(mod1)
usadata$resid <- residuals(mod1)

usadata %>% 
  select(year, lifeExp, predicted, resid)

```


### Graphing Residuals 

A first look at the residuals warrants seeing if there are any values that are poorly predicted. We can graph a histogram of residuals and select the maximum residual to see. But remember, residuals can also be negative, so let's also graph a histogram of the absolute values of the residuals.

```{r resid-hist}

hist(usadata$resid)
hist(abs(usadata$resid))
```
This shows us that, while most residuals are very close to zero, there are still a few that are further away. 

A handy graph in inspecting our regression model is the residual plot. Our x-axis here is the predicted values of life expectancy, and our y-axis is the residuals. 

```{r resid-plot}

ggplot(usadata,
       aes(x = predicted,
           y = resid)) +
  geom_point() +
  geom_hline(yintercept = 0, linetype = "dotted") +
  ggtitle("Residual Plot") +
  theme_classic()

```

Lastly, let's plot this graph side-by-side with our original graph. We're going to use the `plot_grid()` function, contained in the `cowplot` package. Create each graph separately, save each as its own object, then run `cowplot::plot_grid(graph1, graph2)`.


```{r compare-graphs}
origplot <- ggplot(usadata,
                   aes(x = year,
                       y = lifeExp)) +
  geom_point() +
  geom_smooth(method = "lm") +
  ggtitle("Life Expectancy vs. Year") +
  theme_classic()

residplot <- ggplot(usadata,
                    aes(x = predicted,
                        y = resid)) +
  geom_point() +
  geom_hline(yintercept = 0, linetype = "dotted") +
  ggtitle("Residual Plot") +
  theme_classic()

if(!require(cowplot))          # If cowplot package isn't intalled...
  install.packages("cowplot")  # Install it

cowplot::plot_grid(origplot, residplot)
```

If you want to add in the histogram of predicted and residuals onto the residual plot, you can run `ggExtra::ggMarginal(residplot, type="histogram")` and use the new graph in the `plot_grid()`.

```{r compareplot-w-hist}

if(!require(ggExtra))          # If ggExtra package isn't intalled...
  install.packages("ggExtra")  # Install it

residhistplot <- ggExtra::ggMarginal(residplot, type = "histogram")

cowplot::plot_grid(origplot, residhistplot)

```



